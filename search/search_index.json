{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Notes with MkDocs","text":""},{"location":"#mkdocs-help","title":"MkDocs help","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml              # The configuration file.\ndocs/\n    index.md            # This page.\n    personal-notes/     # Notes.\n</code></pre>"},{"location":"personal-notes/Inbox/","title":"Inbox","text":""},{"location":"personal-notes/Assets/Excalidraw/Drawing%202024-07-27%2021.08.57.excalidraw/","title":"Drawing 2024 07 27 21.08.57.excalidraw","text":"<p>==\u26a0  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. \u26a0== You can decompress Drawing data with the command palette: 'Decompress current Excalidraw file'. For more info check in plugin settings under 'Saving'</p>","tags":["excalidraw"]},{"location":"personal-notes/Assets/Excalidraw/Drawing%202024-07-27%2021.08.57.excalidraw/#excalidraw-data","title":"Excalidraw Data","text":"","tags":["excalidraw"]},{"location":"personal-notes/Assets/Excalidraw/Drawing%202024-07-27%2021.08.57.excalidraw/#text-elements","title":"Text Elements","text":"<p>%%</p>","tags":["excalidraw"]},{"location":"personal-notes/Assets/Excalidraw/Drawing%202024-07-27%2021.08.57.excalidraw/#drawing","title":"Drawing","text":"<p><pre><code>N4KAkARALgngDgUwgLgAQQQDwMYEMA2AlgCYBOuA7hADTgQBuCpAzoQPYB2KqATLZMzYBXUtiRoIACyhQ4zZAHoFAc0JRJQgEYA6bGwC2CgF7N6hbEcK4OCtptbErHALRY8RMpWdx8Q1TdIEfARcZgRmBShcZQUebTiATho6IIR9BA4oZm4AbXAwUDAiiBJuCDhNAGsYAAkAcQAhegBmGBgANgB5AEYAJSF8SR59bP5i2EQyx1x9TmJkoshMbmcA\n\nVgAGABZtTe717tX2nlWxyBgVnma4nk329YTmgHYT/MgKEnVububunc2EnjdAAcz1OUgQhGU0i+PDiQJ46x+xzB1mUwW46zBzCgpDYlQQAGE2Pg2KQygBiboIKlUhbFTS4bCVZS4oQcYhEklkiQ46zMOC4QKZOmQABmhHw+AAyrB0RJBB4RRBsbj8QB1D6Sbh8V7KnF4hAymBy9AK0pg1lQjjhbJobpgtgC7Bqc529aY3Us4RwACSxFtqByAF0waL\n\nyOk/dwOAN8GDCOysGVcOslaz2dbmAHCotoPBxLxXgBfLEIBDzO3ff6bLaPR5gxgsdhcNAJdr1pisTgAOU4Yi+30OB02oN1hGYABFUlAy9xRQQwmDNMJ2QBRYLpTIBvKLAqvYqlCSYKUARwAWseAIoAVWP616CFFooAguPsD6AFYJY/6EXjPNJ0hcSoPdC1eENdSEOBiFwady1QbpHlhe5NiBd0EKBMEiA4SooxjTC2CZGc0DnfAwnyYt8mzSAD3Q\n\nI8z0vG87wfZ9Xw/L8fzBCZ8wgQUgKVZY0GcZo7m0VD1keIFumRXVXVQZxunaBJRISdYjheHN3mIT40GaZolMU7pqzUsFJAhKEoC+TZVniHh2kOaSc1RE0PRzFUDU5UkKRpakkEXRlmTTDliU8nlyA4flBQyCzQwlaVZW4s15ixfV1U1bVktVQ14rKRLU2EK0bS+B0nRdL53TBL1IL9LdwJzMMZgQSM0GjSU4wTAT0Fwbo8rZYgMyzPdc0mNAeCLE\n\nsiN4dYgVWVYeFQ7oEnbRtOG1QEls7Dgew4Ps7RuYcEhQ744wnKcJpIhddSXXq1zSKKAxa2MIKgmCJoQpCDtQx5gR1HMsJw5q8N1ElCLg86EDBOA2HjLJcj3bcdxchG91qxZ4cWS52m0R5mi2doQXUnchMebRvjmqTVmR04wDRopdP0hJDNUhzCcM6zYTstTkbAzDQigIl9H0NRYIABSh4U0BpxGinWbndWxQUoAaeNHA4ZRuCoyBUg3KAmvQCpqn\n\nqJpWg6Hp+kGYZRkG0UCKEAN1niQzdKZnHdjmoEEjrQblFwOBuCBbQEgBdpEMD3YthQoExt1DJiCV9l4zVgHWrlqJSCgJ9ALYChTNwOCHrBGOM6AnO4J4zPgKKCiiiokpS6MZQODgIFKgAKU6SQADUgU6R5egAfXHBJSFWDujCVLiyiCIg5F83UOqE+34URcmwVk5xdn9g7ViRAm3jSu1mjZvYHhHHNTMhaED+2ZfmcgJz8ylvVMo87l0EpHzaT8p\n\nlKvZF+yl5cKAohTRV1OKSURoTTKmJOaFOmUNRaS1CNDKBoIEJWgUlXUlpJD9SKrqR0jJSpukfpVX0/pcgozFOGRqedAY5mVomCQuAeA9XTIVNAGshr5lGosKuxQwgTWHKsR4VldL2l1A2DaXwfjrSbFtHaqAgSH2EgiI6o4TrBFgrOec4NLrLmIDdbW91aHFEgtBTRdpEIIg+oZA4Yjfrxn+qgfOQMCL4lBto8iYwa40QgHUdoUB3yngAJo+hbt0\n\nAAGsoTYdQnwEAvKQKwVBOL/kYeXfiKxuhSQDk8XeEA15WO0DfXJmltKoDstsPSQJNg5JMmZS+qB/iYwUvseyuT74YmQfiP+Eh37eSVAyb+gVunoAARFYBSowFxWNGgxUnSEDwNKT9PhKUsrTJyugnqBVMy4JzPg50sAyrENZKQmqoYqG62cXQ9qSZmgsL6mw1AHCJ4jSjq5UscEcYPE2DwBmMiVq7VbH8zavYuHugBECIEdxcljknBos62jFx6IM\n\nXdchYJTEvTgm9KxKFqmHDbEDBxuFk6/VcfC0iOicyQ2hluOGe4wBS2lpTWlO4wA3G0BzW+RQEj+1rM0apzwmU7hpqyzJhTHhFKpmAA4cRg7AgFTuCh1M6XVPtlvHekrvjsruAcTmCqqbCuHL8WafKanKv+DsJmFM9XMp3NZGa4lJKcrAE8JSw5bKtMFajOl8l4SiVPjuRpJNtUeoVbLX6vN+aCxkGWUW0NYYs19fjKmgbmk6uOGG5ZCs44q0Tk44\n\nxmt2TZoTkSx6rlU7p3LiXEtBd2RFyzlW1JfFPGUVHKXBA2BejdGIKKBIwtx4pJGVgEBOYOo/GaIUh1K8ZIXHEn64+pqNL73go/c+5ltRtNVs5OZwyIC9J8v0/yP8gpcn/mFMZUUJmxVQes2ZsCDQLMQbwOZ175QbItPlbBDy7HFD2YQ5dRzvTVVRaA85NDiX7muYwzYdycFJ1LXw952pl4HXZotcRHYmzcGaECuRXDLjVKeLfEo6iEDmNQDiIQFL\n\n6RIvXCiuDaLnpkaxchKph88aYUJfRlxIMtHks4kOsoqZKAABUBMSAmZwKAUpCBGFBaGSTAAxGYEpZLfsgNOTA6ciANzKGITITAlQNigOYAgT5tPNnQILYgxB0Rgj0JkXA8YmC618f4wJISwmROibE/A8TElKlJJCeMBBROacEyiIQUA2D3lYLJ7gFGqOQCwggGodSLJ2niFasAoEwC1R4nAOAMoXrq3yNAUy6QyjaehGMBghAEAUAaIeoZwVX67s\n\nfO10UdIIDYBEMAn0059Aymfi1ryH9Z7FB64BKK/W0iNcGXondoygEXpq5NvrA2FNXuyq+29E3evTYG0N+9S6lndf25kGbg2VkvtNG+0ra2DtpF6B+2D8FVvnZ1gNzoJUDlEPe1Ni7G3FPKfwKp/7620gKck9JuLI1EZnYB59tIoWtOQgsxAYIoph2QAe4DtIRW051uziEMD8GEcQ/0CuWtlaScAT4jV5g2BcSSnCX7QE2gCbKiZ8SfAQTuB3HHfO\n\n/1EAjBsAMCVnM9ACCUa+M2vbiPLvPd6q9iAgUusshIDD/MlzIAa+PSFR5uoGjElLuSAkCRzfm4UwppU95lADEFBSFc45nfO+txAOXOOPtHfxN94znAjHgfKIEMwwhmB1AScQLX1bSv1XSPeBMCTVYS+KBkXAmhghwQS3Z6e8XSCUbBBwBqeeC94Mi8lkvCBPcQDsO+dtWQpRF7gAAWTYMQBAVP0+Z942RbL/AIBgPCOrUChYgA==\n</code></pre> %%</p>","tags":["excalidraw"]},{"location":"personal-notes/Journal/2024-07-28/","title":"2024 07 28","text":""},{"location":"personal-notes/Journal/2024-07-28/#recursion-basic","title":"Recursion Basic","text":"<ul> <li>Print a name N times recursively</li> </ul> <pre><code># Print a name N times recursively\n\ndef print_name_rec(name, curr, N):\n    if curr &gt; N:\n        return\n    print(name, end=\" \")\n    print_name_rec(name, curr + 1, N)\n\nif __name__ == \"__main__\":\n    print_name_rec(\"John\", 1, 5)\n</code></pre> <ul> <li>Print a sequence of numbers in ascending order recursively</li> </ul> <pre><code># Print a sequence of numbers in ascending order recursively\n\ndef print_asc_rec(curr, end):\n    if curr &gt; end:\n        return\n    print(curr, end=\" \")\n    print_asc_rec(curr + 1, end)\n\nif __name__ == \"__main__\":\n    print_asc_rec(1, 10)\n</code></pre> <ul> <li>Print a sequence of numbers in descending order recursively</li> </ul> <pre><code># Print a sequence of numbers in descending order recursively \n\ndef print_desc_rec(curr, end):\n    if curr &lt; end:\n        return\n    print(curr, end=\" \")\n    print_desc_rec(curr - 1, end)\n\nif __name__ == \"__main__\":\n    print_desc_rec(10, 1)\n</code></pre> <ul> <li>Print the sum of first N natural numbers recursively</li> </ul> <pre><code># Print the sum of a sequence of natural numbers\n\ndef sum_first_n_rec(n, curr = 1):\n    if curr &gt; n:\n        return 0\n    return curr + sum_first_n_rec(n, curr + 1)\n\nif __name__ == \"__main__\":\n    sum_total = sum_first_n_rec(10)\n    print(sum_total)\n</code></pre> <ul> <li>Factorial of N numbers recursively</li> </ul> <pre><code># Factorial of N numbers recursively\n\ndef facto_n_rec(n, curr = 1):\n    if curr &gt; n:\n        return 1\n    return curr * facto_n_rec(n, curr + 1)\n\nif __name__ == \"__main__\":\n    facto = facto_n_rec(10)\n    print(facto)\n</code></pre> <ul> <li>Reverse and array recursively</li> </ul> <pre><code># Factorial of N numbers recursively\n\ndef rev_arr_rec(arr, curr):\n    n = len(arr)\n    if curr == int(n / 2):\n        return\n    arr[curr], arr[n - curr - 1] = arr[n - curr - 1], arr[curr]\n    rev_arr_rec(arr, curr + 1)\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    rev_arr_rec(arr, 0)\n    print(arr)\n</code></pre> <ul> <li>Check for Palindrome recursively</li> </ul> <pre><code># Check for Palindrome recursively\n\ndef check_palindrome_rec(string, curr):\n    n = len(string)\n    if curr &gt; int(n / 2):\n        return True\n    if string[curr] != string[n - curr - 1]:\n        return False\n\n    return check_palindrome_rec(string, curr + 1)\n\n\nif __name__ == \"__main__\":\n    string = input()\n    print(check_palindrome_rec(string, 0))\n</code></pre> <ul> <li>Print N fibonacci numbers:</li> </ul> <pre><code># Iterative method\ndef print_n_fibo(n):\n    a = 0\n    b = 1\n    for i in range(1, n + 1):\n        if i == 1:\n            print(0, end=\" \")\n        elif i == 2:\n            print(1, end=\" \")\n        else:\n            b = a + b\n            a = b - a\n            print(b, end=\" \")\n\n# Recursive method\ndef print_n_fibo_rec(n, a = 0, b = 1, curr = 1):\n    if curr &gt; n:\n        return\n    if curr == 1:\n        print(0, end=\" \")\n    elif curr == 2:\n        print(1, end=\" \")\n    else:\n        b = a + b\n        a = b - a\n        print(b, end=\" \")\n    print_n_fibo_rec(n, a, b, curr + 1)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    print_n_fibo_rec(n)\n    print(\"\\n\")\n    print_n_fibo(n)\n</code></pre>"},{"location":"personal-notes/Notes/000_Index_DS_Algo/","title":"Data Structures and Algorithms Index","text":"","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#basics-of-language-and-dsa","title":"Basics of Language and DSA","text":"","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#basics-of-languages","title":"Basics of Languages","text":"","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#input-and-output","title":"Input and Output","text":"<ul> <li>Input_and_Output_in_CPP</li> <li>Input_and_Output_in_Python</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#data-types","title":"Data Types","text":"<ul> <li>Data_Types_in_CPP</li> <li>Data_Types_in_Python</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#flow-of-control","title":"Flow of Control","text":"<ul> <li>Flow_of_Control_in_Python</li> <li>Functions_in_Python</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#templates-and-collections","title":"Templates and Collections","text":"<ul> <li>Collections_in_Python</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#modules","title":"Modules","text":"<ul> <li>Modules_Imports_in_Python</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#helper-snippets","title":"Helper Snippets","text":"<ul> <li>Cpp_helper_snippets</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#oops","title":"OOPS","text":"","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#unit-testing","title":"Unit Testing","text":"","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#basics-of-recursion","title":"Basics of Recursion","text":"<ul> <li>Problems_on_Basic_Recursion</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#sorting","title":"Sorting","text":"<ul> <li>Selection_Sort</li> <li>Bubble_Sort</li> <li>Insertion_Sort</li> <li>Merge_Sort</li> <li>Quick_Sort</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#arrays","title":"Arrays","text":"","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/000_Index_DS_Algo/#easy-problems","title":"Easy Problems","text":"<ul> <li>Second_Largest_Element_in_Array</li> </ul>","tags":["ds-algo/0-index"]},{"location":"personal-notes/Notes/Bubble_Sort/","title":"Bubble Sort","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#bubble-sort-algorithm","title":"Bubble Sort algorithm","text":"<ul> <li> <p>First, we will select the range of the unsorted array using an outer loop(say i). This range initially starts from \\((n - 1)th\\) element and goes upto \\(1st\\) element, running backwards.</p> </li> <li> <p>Within the loop, we will run inner loop(say j, runs from \\(0\\) to \\(i-1\\)).</p> <ul> <li>Within loop \\(j\\) we check <code>if arr[j] &gt; arr[j + 1]</code>. If so we swap <code>arr[j]</code> and <code>arr[j + 1]</code>.</li> <li>At the end of loop \\(j\\), the largest element is bubbled at the end at position \\(i\\).</li> </ul> </li> <li> <p>On the first iteration the entire array (\\(0\\) to \\(n - 1\\)) is the range. On the second range is from \\(0\\) to \\(n - 2\\).</p> <ul> <li>After \\((n-1)\\) iteration, the whole array will be sorted.</li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#notes-on-the-algorithm","title":"Notes on the algorithm","text":"<ul> <li> <p>\\(j\\) runs upto \\((i - 1)th\\) element and not upto \\((i)th\\) element because -</p> <ul> <li>\\(i\\) runs from \\(nth\\) element (<code>i = n - 1</code>) </li> <li>\\(j\\) runs from \\(0\\) to \\(i - 1\\), checking if <code>arr[j] &gt; arr[j + 1]</code>. <ul> <li>We see at <code>j = i - 1</code> when \\(i = n\\) we check if <code>arr[n - 1] &gt; arr[n]</code>.</li> <li>If \\(j\\) ran upto \\((i)th\\) element we will access beyond array limits.</li> </ul> </li> </ul> </li> <li> <p>\\(i\\) runs upto \\(2nd\\) element (<code>i = 1</code>) as the first element will be sorted by default at the last iteration of the inner loop.</p> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#bubble-sort-in-ascending-order","title":"Bubble Sort in Ascending order","text":"<ul> <li>Python Implementation</li> </ul> <pre><code>def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n - 1, 1, -1):\n        for j in  range(0, i):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    bubble_sort(arr)\n    print(arr)\n</code></pre> <ul> <li>C++ Implementation</li> </ul> <pre><code>void bubble_sort(std::vector&lt;int&gt; &amp;arr) {\n    size_t n = arr.size();\n    for (size_t i = n - 1; i &gt; 0; --i) {\n        for (size_t j = 0; j &lt; i; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    bubble_sort(arr);\n\n    print_vector(arr);\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#bubble-sort-in-descending-order","title":"Bubble Sort in Descending order","text":"<ul> <li>Python Implementation</li> </ul> <pre><code>def bubble_sort_desc(arr):\n    n = len(arr)\n    for i in range(n - 1, 1, -1):\n        for j in  range(0, i):\n            if arr[j] &lt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    bubble_sort_desc(arr)\n    print(arr)\n</code></pre> <ul> <li>C++ Implementation</li> </ul> <pre><code>void bubble_sort_desc(std::vector&lt;int&gt; &amp;arr) {\n    size_t n = arr.size();\n    for (size_t i = n - 1; i &gt; 0; --i) {\n        for (size_t j = 0; j &lt; i; j++) {\n            if (arr[j] &lt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    bubble_sort_desc(arr);\n\n    print_vector(arr);\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#time-and-space-complexity","title":"Time and Space Complexity","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#time-complexity","title":"Time Complexity","text":"<ul> <li> <p>\\(O(n^2)\\)</p> <ul> <li>(where N = size of the array), for the worst, and average cases. For bese case see #Check for best case.</li> </ul> </li> <li> <p>Reason: </p> <ul> <li>The outer loop, say \\(i\\), is running from \\(n-1\\) to \\(1\\) i.e. \\(n - 1\\) times,</li> <li> <p>for each \\(i\\), the inner loop \\(j\\) runs from \\(0\\) to \\(i-1\\).</p> <ul> <li>For, \\(i = n-1\\), the inner loop runs n-1 times, </li> <li>for \\(i = n-2\\), the inner loop runs \\(n-2\\) times, and so on. </li> </ul> </li> <li> <p>So, the total steps will be approximately the following: </p> <ul> <li>\\((n-1) + (n-2) + (n-3) + \u2026\u2026..+ 3 + 2 + 1\\).</li> </ul> </li> <li>The summation is approximately the sum of the first n natural numbers i.e. \\((n*(n+1))/2\\). </li> <li>The precise time complexity will be \\(O(n^2/2 + n/2)\\).</li> <li>So Time Complexity is \\(O(n^2)\\). Here the value of n is N i.e. the size of the array.</li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#space-complexity","title":"Space Complexity","text":"<ul> <li>\\(O(1)\\)</li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#check-for-best-case","title":"Check for best case","text":"<ul> <li> <p>We can apply a check to find if the array is already sorted. If so we break   out after the first iteration. This Time Complexity for best case will be   \\(O(N)\\).</p> </li> <li> <p>Python Implementation</p> </li> </ul> <pre><code>def bubble_sort(arr):\n    n = len(arr)\n    did_swap = False\n    for i in range(n - 1, 1, -1):\n        for j in  range(0, i):\n            if arr[j] &gt; arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                did_swap = True\n        if not did_swap:\n            break\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    bubble_sort(arr)\n    print(arr)\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Bubble_Sort/#references","title":"References","text":"<ol> <li>Cpp_helper_snippets</li> </ol>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Collections_in_Python/","title":"Collections in Python","text":"<p>000_Index_DS_Algo</p> <ul> <li>Strings_in_Python</li> <li>Lists_in_Python</li> <li>Tuples_in_Python</li> <li>Dictionaries_in_Python</li> <li> <p>Sets_in_Python</p> </li> <li> <p>Operation_on_Python_Collections</p> </li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Collections_in_Python/#related-pages","title":"Related Pages","text":"<ul> <li>Input_and_Output_in_Python</li> <li>Data_Types_in_Python</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Collections_in_Python/#references","title":"References","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/","title":"C++ code snippets","text":"","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/#split-a-string","title":"Split a string","text":"<pre><code>template &lt;typename T&gt; std::vector&lt;T&gt; split(const std::string &amp;str, char delim) {\n    std::vector&lt;T&gt; tokens;\n    std::string token;\n    std::istringstream iss(str);\n\n    while (std::getline(iss, token, delim)) {\n        std::istringstream converter(token);\n        T value;\n        converter &gt;&gt; value;\n\n        if (!converter.fail()) {\n            tokens.push_back(value);\n        }\n    }\n\n    return tokens;\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/#print-a-vector","title":"Print a Vector","text":"<pre><code>template &lt;typename T&gt; void print_vector(const std::vector&lt;T&gt; &amp;tokens) {\n    std::stringstream output;\n    output &lt;&lt; \"[\";\n    for (size_t i = 0; i &lt; tokens.size(); ++i) {\n        if (i != tokens.size() - 1) {\n            output &lt;&lt; tokens[i] &lt;&lt; \", \";\n        } else {\n            output &lt;&lt; tokens[i];\n        }\n    }\n    output &lt;&lt; \"]\";\n    std::cout &lt;&lt; output.str();\n}\n</code></pre>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/#swap-two-values","title":"Swap two values","text":"<pre><code>template &lt;typename T&gt; void swap(T &amp;a, T &amp;b) {\n    T temp = a;\n    a = b;\n    b = temp;\n}\n</code></pre>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/#class-to-redirect-input-and-output-to-files","title":"Class to Redirect Input and Output to files","text":"<pre><code>#include &lt;fstream&gt;\n\nclass IORedirector {\nprivate:\n    std::unique_ptr&lt;std::streambuf&gt; m_cin_buffer;\n    std::unique_ptr&lt;std::streambuf&gt; m_cout_buffer;\n    std::ifstream m_in;\n    std::ofstream m_out;\n\npublic:\n    IORedirector(const std::string&amp; input_file, const std::string&amp; output_file) {\n        if (!input_file.empty()) {\n            m_in.open(input_file);\n            if (m_in.is_open()) {\n                m_cin_buffer.reset(std::cin.rdbuf(m_in.rdbuf()));\n            }\n        }\n\n        if (!output_file.empty()) {\n            m_out.open(output_file);\n            if (m_out.is_open()) {\n                m_cout_buffer.reset(std::cout.rdbuf(m_out.rdbuf()));\n            }\n        }\n    }\n\n    ~IORedirector() {\n        if (m_cin_buffer) std::cin.rdbuf(m_cin_buffer.release());\n        if (m_cout_buffer) std::cout.rdbuf(m_cout_buffer.release());\n    }\n};\n\n// Usage\nint main() {\n    IORedirector io_red(\"input.txt\", \"output.txt\");\n\n    // code goes here ...\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/#makefile","title":"Makefile","text":"<pre><code>CXX = clang++\nCXXFLAGS = -std=c++17 -g -Wall -Wextra -pedantic\nTARGET = main\nSRCS = main.cpp helper.cpp\nOBJS = $(SRCS:.cpp=.o)\n\n.PHONY: all clean\n\nall: $(TARGET)\n\n$(TARGET): $(OBJS)\n    $(CXX) $(CXXFLAGS) -o $@ $^\n\n%.o: %.cpp\n    $(CXX) $(CXXFLAGS) -c $&lt; -o $@\n\nclean:\n    rm -rf $(OBJS) $(TARGET) *.dSYM *.out\n\nrun: $(TARGET)\n    ./$(TARGET)\n</code></pre>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/#usage-of-makefile","title":"Usage of Makefile","text":"<ul> <li> <p>To build the project use <code>make</code>.</p> </li> <li> <p>To build and run (or run if already built) use <code>make run</code>.</p> </li> <li> <p>To clean the project use <code>make clean</code>.</p> </li> </ul>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Cpp_helper_snippets/#references","title":"References","text":"","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Data_Types_in_CPP/","title":"Data Types in C++","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Data_Types_in_CPP/#strings-and-getline","title":"Strings and <code>getline</code>","text":"<ul> <li>To use strings use <code>#include&lt;string&gt;</code>.</li> <li>To read a single line from input at a time use</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    string str;\n    getline(cin, str);\n\n    // .. Other code here\n}\n</code></pre>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Data_Types_in_CPP/#related-pages","title":"Related Pages","text":"<ul> <li>Data_Types_in_Python</li> </ul>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Data_Types_in_CPP/#references","title":"References","text":"","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Data_Types_in_Python/","title":"Data Types in Python","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Data_Types_in_Python/#atomic-data-types","title":"Atomic Data Types","text":"<ul> <li><code>int</code></li> <li><code>float</code></li> <li><code>bool</code></li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Data_Types_in_Python/#to-get-the-type-of-an-object","title":"To get the type of an object","text":"<pre><code>x = 5\nprint(type(x))  # &lt;class 'int'&gt;\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Data_Types_in_Python/#to-type-cast-use","title":"To type-cast use","text":"<pre><code>number = 73\nx = str(number)\nprint(type(x))  # &lt;class 'str'&gt;\n\nprint(float(\"inf\") + 1) # inf\n</code></pre> <ul> <li>type and class are often used for same meaning.</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Data_Types_in_Python/#variables-and-objects","title":"Variables and Objects","text":"<ul> <li>Note the expression -</li> </ul> <pre><code>x = [1, 2, 3]\n</code></pre> <ul> <li>Here\u00a0<code>x</code>\u00a0is a variable.\u00a0<code>[1, 2, 3]</code>\u00a0is an\u00a0object\u00a0in memory. An object once created can't be reused.</li> <li>We can re-assign\u00a0<code>x</code>\u00a0to a new object.</li> </ul> <pre><code>x = \"Hello\"      # [1, 2, 3] is not used. A new object is created\n</code></pre> <ul> <li> <p>Object can have</p> <ul> <li>Identity</li> <li>Type</li> <li>Value</li> </ul> </li> <li> <p>For atomic types all the above can't be changed. For other types value may or may not be changed. </p> <ul> <li>For ex.\u00a0a string is immutable\u00a0- it's value can't be changed, but a list isn't - we can add or delete elements thus changing it's value.</li> </ul> </li> <li> <p>To check if the variables are referring to same object use\u00a0<code>is</code>\u00a0keyword.</p> </li> </ul> <pre><code>x = [1, 2, 3]\ny = x;\nz = [1, 2, 3]\n\nprint(x is y)   # True\nprint(x is z)   # False\nprint(x == z)   # True\n</code></pre> <ul> <li>To represent infinity use. (Don't use\u00a0<code>int</code>)</li> </ul> <pre><code>thisworks = float(\"inf\")\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Data_Types_in_Python/#related-pages","title":"Related Pages","text":"<ul> <li>Input_and_Output_in_Python</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Data_Types_in_Python/#references","title":"References","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Dictionaries_in_Python/","title":"Dictionaries in Python","text":"<p>000_Index_DS_Algo Collections_in_Python</p> <ul> <li> <p>The name of the class for dictionaries is <code>dict</code>.</p> </li> <li> <p>Collection of key value pairs. The order of the key-value-pairs is not defined.</p> </li> </ul> <pre><code>d = dict()          # Empty Dictionary\nd[5] = \"five\"       # key 5 not present - creating one\nd[2] = \"two\"\nd[\"pi\"] = 3.1415926\n\nprint(type(d))      # &lt;class 'dict'&gt;\nprint(d)            # {5: 'five', 2: 'two', 'pi': 3.1415926}\nprint(d[\"pi\"])      # 3.1415926\n</code></pre> <ul> <li> <p>Keys can be either an atomic type (<code>int</code>, <code>float</code>, <code>boolean</code>), or <code>string</code>, or <code>tuple</code> - i.e. it has to be immutable.</p> </li> <li> <p>If we assign to a key that's not already present in the dictionary -   it creates a new key (as shown in the above example).</p> </li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Dictionaries_in_Python/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Dictionaries_in_Python/#references","title":"References","text":"<ol> <li>Dictionaries-Python_docs</li> </ol>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/","title":"Flow of Control in Python","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/#if-statements","title":"If statements","text":"<ul> <li>We have <code>if</code>, <code>elif</code>, <code>else</code></li> </ul> <pre><code>if 2 + 2 &lt; 3:\n    print(\"Test - 01\")\nelif 3+2 &gt; 6:\n    print(\"Test - 02\")\nelse:\n    print(\"Test - 03\")\n</code></pre> <ul> <li> <p>Note the colon <code>:</code> at the end.</p> </li> <li> <p>Equality operators like  <code>!= , &gt;, &lt;, &gt;=, ==, &lt;=</code> work the same.</p> </li> <li> <p>The value of true is <code>True</code> (capital T) and false is <code>False</code> (capital F).</p> </li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/#switch-case-only-applicable-in-python-310","title":"switch - case (Only applicable in Python 3.10)","text":"<ul> <li> <p>In place of switch we have the <code>match</code> keyword</p> </li> <li> <p><code>_</code> - default case</p> </li> </ul> <pre><code>match term:\n    case pattern-1:\n        action-1\n    case pattern-2:\n        action-2\n    case pattern-3:\n        action-3\n    case _:\n        action-default\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/#while-loop","title":"<code>while</code> loop","text":"<ul> <li><code>while</code> works same. Note the <code>:</code> at end.</li> </ul> <pre><code>x = 1                   # initialize\nwhile x &lt; 128:          # condition\n    print(x, end=\" \")\n    x = x * 2           # update\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/#break-and-continue","title":"<code>break</code> and <code>continue</code>","text":"<ul> <li><code>break</code> and <code>continue</code> works as usual.</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/#for-loop","title":"<code>for</code> loop","text":"<ul> <li>Note Operation_on_Python_Collections#Iteration</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/#exception-handling","title":"Exception handling","text":"<ul> <li> <p>We use <code>except</code> to catch an exception.</p> </li> <li> <p>Use <code>raise</code> to manually throw exceptions</p> </li> </ul> <pre><code>x = \"not a number\"\ntry:\n    f = float(x)        # or `raise ValueError(\"An Error\")`\nexcept ValueError:      # catch if it's ValueError\n    print(\"You can't do that!\")\n</code></pre> <ul> <li><code>Exception</code> is the wildcard that catches everything.</li> </ul> <pre><code>try:\n    raise Exception('spam', 'eggs')\nexcept Exception as err:\n    print(type(err))    # &lt;class 'Exception'&gt;\n    print(err.args)     # ('spam', 'eggs')\n    print(err)          # ('spam', 'eggs') \n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/#related-pages","title":"Related Pages","text":"<ul> <li>Functions_in_Python</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Flow_of_Control_in_Python/#references","title":"References","text":"<ol> <li>Python switch case example</li> </ol>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Functions_in_Python/","title":"Functions in Python","text":"<p>000_Index_DS_Algo</p> <ul> <li>Function is defined as follows:</li> </ul> <pre><code>def fib(n):\n    \"\"\"Print a Fibonacci series up to n.\"\"\" # documentation string\n    a, b = 0, 1\n    while a &lt; n:\n        print(a, end=' ')\n        a, b = b, a + b     # technique for swapping a and b\n    print()\n\n    # returns None\n</code></pre> <ul> <li> <p>Functions must be defined by <code>def</code> keyword.</p> </li> <li> <p>Note that <code>\"\"\"</code> for documentation of functions.</p> </li> <li> <p>Functions are objects.</p> <ul> <li>If we define a function twice, even if we change the parameters, the first will be overwritten by the second.</li> </ul> </li> </ul> <pre><code>def foo(x):\n    return x + 2\n\ndef bar(someFunction):\n    return someFunction(4)\n\nprint(bar(foo))                 # 6\nsomeVariable = foo \nprint(bar(someVariable))        # 6\n</code></pre> <ul> <li>The\u00a0<code>return</code> \u00a0statement returns with a value from a function.\u00a0<code>return</code>\u00a0without an expression argument returns\u00a0<code>None</code>. Falling off the end of a function also returns\u00a0<code>None</code>.</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Functions_in_Python/#default-arguments","title":"Default Arguments","text":"<ul> <li>Default arguments work as usual -</li> </ul> <pre><code>def f(arg=\"Test\"):\n    print(arg)\n\nf()            # Test\n</code></pre> <ul> <li>The default value could be a variable or constant. They are evaluated at the point of function definition in the\u00a0defining\u00a0scope.</li> </ul> <pre><code>i = 5\n\ndef f(arg=i):\n    print(arg)\n\ni = 6\nf()              # prints 5\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Functions_in_Python/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Functions_in_Python/#references","title":"References","text":"<ol> <li>Python Docs</li> </ol>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Input_and_Output_in_CPP/","title":"Input and Output in C++","text":"<p>000_Index_DS_Algo</p> <ul> <li>Create two files <code>input.txt</code> and <code>output.txt</code>, for input and output.</li> <li>Within <code>main</code> use the following:</li> </ul> <pre><code>int main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    // ... Other code here\n}\n</code></pre>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Input_and_Output_in_CPP/#related-pages","title":"Related Pages","text":"<ul> <li>Input_and_Output_in_Python</li> </ul>","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Input_and_Output_in_CPP/#references","title":"References","text":"","tags":["ds-algo/lang-basic/cpp"]},{"location":"personal-notes/Notes/Input_and_Output_in_Python/","title":"Input and Output in Python","text":"<p>000_Index_DS_Algo</p> <ul> <li>Create two files <code>input.txt</code> and <code>output.txt</code>, for input and output.<ul> <li>For error use <code>error.txt</code></li> </ul> </li> <li>Within script use the following at the top:</li> </ul> <pre><code>import sys\n\nsys.stdin = open(r\"./input.txt\", \"r\")\nsys.stdout = open(r\"./output.txt\", \"w\")\nsys.stderr = open(r\"./error.txt\", \"w\")\n</code></pre> <ul> <li>For input and output use the following:</li> </ul> <pre><code>p = input()           # Read entire line\nprint(p)              # print to stdout\nsys.stderr.write(p)   # print to stderr\n</code></pre> <ul> <li>To input a sequence of numbers from stdin to an array use</li> </ul> <pre><code># assuming numbers are separated by ,\narr = [int(ch.strip()) for ch in input().split(\",\")]\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Input_and_Output_in_Python/#related-pages","title":"Related Pages","text":"<ul> <li>Input_and_Output_in_CPP</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Input_and_Output_in_Python/#references","title":"References","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Insertion_Sort/","title":"Insertion Sort","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#insertion-sort-algorithm","title":"Insertion Sort algorithm","text":"<ul> <li> <p>Assume the given array to be of two sub-arrays -</p> <ul> <li>the left sub-array being sorted always</li> <li>the right one being unsorted</li> </ul> </li> <li> <p>The first element being the only element in the left sub-array is thus always sorted.</p> </li> <li> <p>Start from second element. Put it in the correct position in the sorted part.</p> </li> <li> <p>Continue till last element.</p> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#notes-on-algorithm","title":"Notes on algorithm","text":"<ul> <li>Since the left half is always sorted - for the element at \\(j\\)<ul> <li>Check if the number before it is greater (or smaller). If so we need to position \\(jth\\) element in proper place.</li> <li>We swap <code>arr[j]</code> with <code>arr[j - 1]</code>. We decrement \\(j\\).</li> <li>We continue this until <code>j &gt; 0</code> and \\(arr[j]\\) is smaller than it's previous element.<ul> <li>When the above condition fails - that means the left sub-array is now sorted.</li> </ul> </li> </ul> </li> <li>We see that \\(j\\) starts from \\(ith\\) element and goes upto second element and not the first element.<ul> <li>This is so as we check <code>arr[j] &lt; arr[j - 1]</code>. if <code>j = 0</code> then <code>arr[-1]</code> will not be correct.</li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#insertion-sort-in-ascending-order","title":"Insertion Sort in Ascending order","text":"<ul> <li>Python Implementation</li> </ul> <pre><code>def insertion_sort(arr):\n    n = len(arr)\n    for i in range(1, n):\n        j = i\n        while j &gt; 0 and arr[j] &lt; arr[j - 1]:\n            arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            j -= 1\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    insertion_sort(arr)\n    print(arr)\n</code></pre> <ul> <li>C++ Implementation</li> </ul> <pre><code>void insertion_sort(std::vector&lt;int&gt; &amp;arr) {\n    size_t n = arr.size();\n    for (size_t i = 1; i &lt; n; ++i) {\n        for (size_t j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; --j) {\n            swap(arr[j], arr[j - 1]);\n        }\n    }\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    insertion_sort(arr);\n\n    print_vector(arr);\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#insertion-sort-in-descending-order","title":"Insertion Sort in descending order","text":"<ul> <li>Python Implementation</li> </ul> <pre><code>def insertion_sort_desc(arr):\n    n = len(arr)\n    for i in range(1, n):\n        j = i\n        while j &gt; 0 and arr[j] &gt; arr[j - 1]:\n            arr[j], arr[j - 1] = arr[j - 1], arr[j]\n            j -= 1\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    insertion_sort_desc(arr)\n    print(arr)\n</code></pre> <ul> <li>C++ Implementation</li> </ul> <pre><code>void insertion_sort_desc(std::vector&lt;int&gt; &amp;arr) {\n    size_t n = arr.size();\n    for (size_t i = 1; i &lt; n; ++i) {\n        for (size_t j = i; j &gt; 0 &amp;&amp; arr[j] &gt; arr[j - 1]; --j) {\n            swap(arr[j], arr[j - 1]);\n        }\n    }\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    insertion_sort_desc(arr);\n\n    print_vector(arr);\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#time-and-space-complexities","title":"Time and Space Complexities","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#time-complexity","title":"Time Complexity","text":"<ul> <li>\\(O(n^2)\\) <ul> <li>(where N = size of the array), for worst and average cases.</li> </ul> </li> <li> <p>\\(O(n)\\)</p> <ul> <li>for best case.</li> </ul> </li> <li> <p>Reason: </p> <ul> <li>The outer loop, say i, is running from \\(1\\) to \\(n-1\\) i.e. \\(n - 1\\) times,</li> <li> <p>for each \\(i\\), the inner loop \\(j\\) runs from \\(i\\) to \\(1\\) i.e. \\(i\\) times. </p> <ul> <li>For, \\(i = 1\\), the inner loop runs \\(1\\) time, </li> <li>for \\(i = 2\\), the inner loop runs 2 times, and so on. </li> </ul> </li> <li> <p>So, the total steps will be approximately the following: </p> <ul> <li>\\(1 + 2 + 3 +\u2026\u2026+ (n-2) + (n-1)\\). </li> </ul> </li> <li>The summation is approximately the sum of the first n natural numbers i.e. \\((n*(n+1))/2\\).</li> <li>The precise time complexity will be \\(O(n^2/2 + n/2)\\). </li> <li> <p>So Time Complexity is \\(O(n^2)\\). Here the value of n is N i.e. the size of the array.</p> </li> <li> <p>For best case the array is already sorted - thus the inner loop body   never executes.</p> </li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#space-complexity","title":"Space Complexity","text":"<ul> <li>\\(O(1)\\)</li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Insertion_Sort/#references","title":"References","text":"<ol> <li>Cpp_helper_snippets</li> </ol>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Lists_in_Python/","title":"Lists in Python","text":"<p>000_Index_DS_Algo Collections_in_Python</p> <ul> <li>Ordered sequence of objects - which can have any types. There are no arrays with pre-defined data-type in python.</li> </ul> <pre><code>L = [1, 2, \"test\"]\n\nprint(type(L))   # &lt;class 'list'&gt;\n</code></pre> <ul> <li>The content of a list like strings can be accessed using a zero based index. A negative index signifies counting from reverse.</li> </ul> <p>NOTE The last element is  <code>L(-1)</code> and NOT <code>L(-0)</code>.</p> <ul> <li> <p><code>L.append(100)</code> - Appends at the back of list.</p> </li> <li> <p>Lists are not immutable. We can update existing values.</p> </li> <li> <p>An empty list is created as (<code>len</code> measures length of any sequence)</p> </li> </ul> <pre><code>L = []\nprint(len(L))   # 0\n</code></pre> <ul> <li>A list of length <code>n</code> initialised with say 0 (it could be any thing) can   be declared as:</li> </ul> <pre><code>L = [0] * n\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Lists_in_Python/#related-pages","title":"Related Pages","text":"<ul> <li>Strings_in_Python</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Lists_in_Python/#references","title":"References","text":"<ol> <li>Lists-Python Docs</li> <li>More_Lists-Python Docs</li> </ol>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Merge_Sort/","title":"Merge Sort","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#merge-sort-algorithm","title":"Merge Sort algorithm","text":"<ul> <li> <p>The array is to be broken recursively from the middle into sub-arrays until subarrays are sorted.</p> <ul> <li>All of the subarrays are sorted when each subarray is of length \\(1\\).</li> </ul> </li> <li> <p>Now we recursively merge the individual arrays back.</p> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#notes-on-implementation","title":"Notes on implementation","text":"<ul> <li>We use the index of the array to break it into sub-array hypothetically.<ul> <li>We break the array in the middle. Left half is one array. The right half is the other one.</li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#notes-on-merge-function","title":"Notes on <code>merge</code> function","text":"<ul> <li> <p>We create an auxiliary array to store the sorted elements.</p> </li> <li> <p>We start two pointers one from starting of left subarray, another from right subarray. </p> <ul> <li>We compare individual pointed elements. </li> <li>Based on the order we place them in the auxiliary array.</li> </ul> </li> <li> <p>When either left or right subarray is exhausted, we copy remaining elements from the other subarray      to auxiliary array. Note individual subarrays are sorted by definition.</p> </li> <li> <p>Now we copy the elements from auxiliary array back to main array.</p> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#merge-sort-in-ascending-order","title":"Merge Sort in ascending order","text":"<ul> <li>Python Implementation</li> </ul> <pre><code>def merge(arr, left, mid, right):\n    aux_arr = []\n    l = left\n    r = mid + 1\n    while l &lt;= mid and r &lt;= right:\n        if arr[l] &lt;= arr[r]:\n            aux_arr.append(arr[l])\n            l += 1\n        else:\n            aux_arr.append(arr[r])\n            r += 1\n    while l &lt;= mid:\n        aux_arr.append(arr[l])\n        l += 1\n    while r &lt;= right:\n        aux_arr.append(arr[r])\n        r += 1\n\n    for i in range(left, right + 1):\n        arr[i] = aux_arr[i - left]\n\n\ndef merge_sort(arr, left, right):\n    if left &gt;= right:\n        return\n    mid = left + int((right - left) / 2)\n    merge_sort(arr, left, mid)\n    merge_sort(arr, mid + 1, right)\n    merge(arr, left, mid, right)\n\n\nif __name__ == \"__main__\":\n    input_arr = [int(ch.strip()) for ch in input().split(\",\")]\n    merge_sort(input_arr, 0, len(input_arr) - 1)\n    print(input_arr)\n</code></pre> <ul> <li>C++ Implementation</li> </ul> <pre><code>void merge(std::vector&lt;int&gt; &amp;arr, size_t left, size_t mid, size_t right) {\n    std::vector&lt;int&gt; aux_arr;\n    size_t l = left, r = mid + 1;\n    while (l &lt;= mid &amp;&amp; r &lt;= right) {\n        if (arr[l] &lt; arr[r]) {\n            aux_arr.push_back(arr[l]);\n            l++;\n        } else {\n            aux_arr.push_back(arr[r]);\n            r++;\n        }\n    }\n\n    while (l &lt;= mid) {\n        aux_arr.push_back(arr[l++]);\n    }\n\n    while (r &lt;= right) {\n        aux_arr.push_back(arr[r++]);\n    }\n\n    for (size_t i = 0; i &lt; aux_arr.size(); i++) {\n        arr[left + i] = aux_arr[i];\n    }\n}\n\nvoid merge_sort(std::vector&lt;int&gt; &amp;arr, size_t left, size_t right) {\n    if (left &gt;= right) {\n        return;\n    }\n    size_t mid = left + (right - left) / 2;\n    merge_sort(arr, left, mid);\n    merge_sort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    merge_sort(arr, 0, arr.size() - 1);\n\n    print_vector(arr);\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#merge-sort-in-descending-order","title":"Merge Sort in Descending Order","text":"<ul> <li>Python Implementation</li> </ul> <pre><code>def merge_desc(arr, left, mid, right):\n    aux_arr = []\n    l = left\n    r = mid + 1\n    while l &lt;= mid and r &lt;= right:\n        if arr[l] &gt;= arr[r]:\n            aux_arr.append(arr[l])\n            l += 1\n        else:\n            aux_arr.append(arr[r])\n            r += 1\n    while l &lt;= mid:\n        aux_arr.append(arr[l])\n        l += 1\n    while r &lt;= right:\n        aux_arr.append(arr[r])\n        r += 1\n\n    for i in range(left, right + 1):\n        arr[i] = aux_arr[i - left]\n\n\ndef merge_sort_desc(arr, left, right):\n    if left &gt;= right:\n        return\n    mid = left + int((right - left) / 2)\n    merge_sort_desc(arr, left, mid)\n    merge_sort_desc(arr, mid + 1, right)\n    merge_desc(arr, left, mid, right)\n\n\nif __name__ == \"__main__\":\n    input_arr = [int(ch.strip()) for ch in input().split(\",\")]\n    merge_sort_desc(input_arr, 0, len(input_arr) - 1)\n    print(input_arr)\n</code></pre> <ul> <li>C++ Implementation</li> </ul> <pre><code>void merge_desc(std::vector&lt;int&gt; &amp;arr, size_t left, size_t mid, size_t right) {\n    std::vector&lt;int&gt; aux_arr;\n    size_t l = left, r = mid + 1;\n    while (l &lt;= mid &amp;&amp; r &lt;= right) {\n        if (arr[l] &gt; arr[r]) {\n            aux_arr.push_back(arr[l]);\n            l++;\n        } else {\n            aux_arr.push_back(arr[r]);\n            r++;\n        }\n    }\n\n    while (l &lt;= mid) {\n        aux_arr.push_back(arr[l++]);\n    }\n\n    while (r &lt;= right) {\n        aux_arr.push_back(arr[r++]);\n    }\n\n    for (size_t i = 0; i &lt; aux_arr.size(); i++) {\n        arr[left + i] = aux_arr[i];\n    }\n}\n\nvoid merge_sort_desc(std::vector&lt;int&gt; &amp;arr, size_t left, size_t right) {\n    if (left &gt;= right) {\n        return;\n    }\n    size_t mid = left + (right - left) / 2;\n    merge_sort_desc(arr, left, mid);\n    merge_sort_desc(arr, mid + 1, right);\n    merge_desc(arr, left, mid, right);\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    merge_sort_desc(arr, 0, arr.size() - 1);\n\n    print_vector(arr);\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#time-and-space-complexity","title":"Time and Space Complexity","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#time-complexity","title":"Time Complexity","text":"<ul> <li> <p>\\(O(nlog(n))\\)</p> <ul> <li>Reason: At each step, we divide the whole array, for that \\(log(n)\\). We assume     \\(n\\) steps are taken to get sorted array, for each division so overall time      complexity will be \\(nlog(n)\\).</li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#space-complexity","title":"Space Complexity","text":"<ul> <li> <p>\\(O(n)\\)</p> <ul> <li>Reason: We are using a temporary array to store elements in sorted order.</li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Merge_Sort/#references","title":"References","text":"<ol> <li>Cpp_helper_snippets</li> </ol>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Modules_Imports_in_Python/","title":"Modules &amp; Import in Python","text":"<p>000_Index_DS_Algo</p> <ul> <li> <p>A single <code>.py</code> file is a Module. To import one module into another use <code>import</code> keyword. The name of a module, by default, is the name of the file (without the <code>.py</code> extension)</p> </li> <li> <p>When we import a module - the code within the module is executed. </p> </li> <li> <p>Assume two files <code>main.py</code>  and <code>lib.py</code> .  We are running <code>main.py</code>.</p> </li> </ul> <pre><code># In file lib.py\ndef f(x):\n    return 2 * x + 3\n\ndef g(x):\n    return x ** 2 - 1\n\n# In file main.py\nimport lib\n\ndef f(x):\n    return x - 1\n\nprint(lib.f(1))          # 5\nprint(f(1))              # 0\nprint(lib.g(4))          # 15\n</code></pre> <ul> <li> <p>We see that we have <code>f</code> defined in <code>main</code> as well as <code>lib</code>. To use <code>lib</code> we need to use <code>lib.f()</code>.</p> </li> <li> <p>The module that is being run is called the script. <code>main</code> is the script in the above example.</p> </li> <li> <p>Every module has attributes. <code>__name__</code> is one of them.</p> <ul> <li>For script file <code>__name__ = \"__main__\"</code></li> <li> <p>For other modules <code>__name__ = \"lib\"</code> - No <code>__</code> here.</p> </li> <li> <p>This can be helpful if we want to run something only from the file that is being run.</p> </li> </ul> </li> <li> <p>Modules are only executed the first time they are imported. If  we import the same module twice, the namespace exists and can be accessed for the second one.</p> </li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Modules_Imports_in_Python/#import-variations","title":"Import variations","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Modules_Imports_in_Python/#from-modulename-import-thethingiwanted","title":"<code>from modulename import thethingIwanted</code>","text":"<ul> <li>This brings the new name <code>thethingIwanted</code> into the current namespace. <ul> <li>It doesn\u2019t need to be preceded by <code>modulename</code> and a dot.</li> </ul> </li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Modules_Imports_in_Python/#from-modulename-import","title":"<code>from modulename import *</code>","text":"<ul> <li>Every name defined in the module will be accessible in the current namespace. <ul> <li>It doesn\u2019t need to be preceded by <code>modulename</code> and a dot.</li> </ul> </li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Modules_Imports_in_Python/#import-numpy-as-np","title":"<code>import numpy as np</code>","text":"<ul> <li>We can write <code>np.array</code> instead of <code>numpy.array</code>. This can help avoid naming conflicts.</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Modules_Imports_in_Python/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Modules_Imports_in_Python/#references","title":"References","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Operation_on_Python_Collections/","title":"Operations on Collections in Python","text":"<p>000_Index_DS_Algo Collections_in_Python</p>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Operation_on_Python_Collections/#length","title":"Length","text":"<ul> <li>To get the length of any collection use <code>len()</code></li> </ul> <pre><code>print(len(s))       # 2\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Operation_on_Python_Collections/#slicing-for-list-tuple-and-string","title":"Slicing (For <code>list</code>, <code>tuple</code>, and <code>string</code>)","text":"<ul> <li> <p><code>slice</code> is only defined when the type has a fixed ordering.</p> </li> <li> <p><code>slice</code> will start with the first index and proceed up to but not including the last index.</p> </li> <li> <p>Negative index count backwards from the end.</p> </li> <li> <p>If we don't mention the first index  - starts from index <code>0</code>.</p> </li> <li> <p>Leaving the last index - will continue till last.</p> </li> <li> <p>Slicing creates a new sequence. Thus for a big collection it is not advisable to use <code>slice</code>.</p> </li> </ul> <pre><code>a = \"a string\"\nb = [\"my\", \"second\", \"favorite\", \"list\"]\nc = (1, 2, 3, \"tuple\")\nprint(a[3:7])       # trin\nprint(a[1:-2])      # ' stri'\nprint(b[1:])        # ['second', 'favorite', 'list']\nprint(c[:2])        # (1, 2)\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Operation_on_Python_Collections/#iteration","title":"Iteration","text":"<ul> <li> <p>Iterating with a <code>for</code> loop</p> </li> <li> <p>Note the syntax</p> </li> </ul> <pre><code>for obj in Objects\n</code></pre> <pre><code>mylist = [1, 3, 5]\nmytuple = (1, 2, \"skip a few\", 99, 100)\nmyset = {\"a\", \"b\", \"z\"}\nmystring = \"abracadabra\"\nmydict = {\"a\": 96, \"b\": 97, \"c\": 98}\n\nfor item in mylist:\n    print(item, end=\" \")            # 1 3 5\n\nfor item in mytuple:\n    print(item, end=\" \")            # 1 2 skip a few 99 100\n\nfor element in myset:\n    print(element, end=\" \")         # z a b\n\nfor character in mystring:\n    print(character, end=\" \")       # a b r a c a d a b r a\n\nfor key in mydict:\n    print(key, end=\" \")             # a b c\n\nfor key, value in mydict.items():\n    print(key, value, end=\" \")      # a 96 b 97 c 98\n\nfor value in mydict.values():\n    print(value, end=\" \")           # 96 97 98\n</code></pre> <ul> <li>Use the function <code>range()</code> to represent a sequence a numbers.</li> </ul> <pre><code>for i in range(5):\n    print(i, end=\" \")               # 0 1 2 3 4\n\nfor i in range(2, 5):\n    print(i, end=\" \")               # 2 3 4\n</code></pre> <p>NOTE <code>range()</code> - starting index starts from index itself, ending index is one last number before   the mentioned number as shown in the example.</p>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Operation_on_Python_Collections/#related-pages","title":"Related Pages","text":"<ul> <li>Flow_of_Control_in_Python</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Operation_on_Python_Collections/#references","title":"References","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Problems_on_Basic_Recursion/","title":"Problems on Basic Recursion","text":"<ul> <li>Print a name N times recursively</li> </ul> <pre><code># Print a name N times recursively\n\ndef print_name_rec(name, curr, N):\n    if curr &gt; N:\n        return\n    print(name, end=\" \")\n    print_name_rec(name, curr + 1, N)\n\nif __name__ == \"__main__\":\n    print_name_rec(\"John\", 1, 5)\n</code></pre> <ul> <li>Print a sequence of numbers in ascending order recursively</li> </ul> <pre><code># Print a sequence of numbers in ascending order recursively\n\ndef print_asc_rec(curr, end):\n    if curr &gt; end:\n        return\n    print(curr, end=\" \")\n    print_asc_rec(curr + 1, end)\n\nif __name__ == \"__main__\":\n    print_asc_rec(1, 10)\n</code></pre> <ul> <li>Print the sum of first N natural numbers recursively</li> </ul> <pre><code># Print the sum of a sequence of natural numbers\n\ndef sum_first_n_rec(n, curr = 1):\n    if curr &gt; n:\n        return 0\n    return curr + sum_first_n_rec(n, curr + 1)\n\nif __name__ == \"__main__\":\n    sum_total = sum_first_n_rec(10)\n    print(sum_total)\n</code></pre> <ul> <li>Factorial of N numbers recursively</li> </ul> <pre><code># Factorial of N numbers recursively\n\ndef facto_n_rec(n, curr = 1):\n    if curr &gt; n:\n        return 1\n    return curr * facto_n_rec(n, curr + 1)\n\nif __name__ == \"__main__\":\n    facto = facto_n_rec(10)\n    print(facto)\n</code></pre> <ul> <li>Reverse and array recursively</li> </ul> <pre><code># Factorial of N numbers recursively\n\ndef rev_arr_rec(arr, curr):\n    n = len(arr)\n    if curr == int(n / 2):\n        return\n    arr[curr], arr[n - curr - 1] = arr[n - curr - 1], arr[curr]\n    rev_arr_rec(arr, curr + 1)\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    rev_arr_rec(arr, 0)\n    print(arr)\n</code></pre> <ul> <li>Check for Palindrome recursively</li> </ul> <pre><code># Check for Palindrome recursively\n\ndef check_palindrome_rec(string, curr):\n    n = len(string)\n    if curr &gt; int(n / 2):\n        return True\n    if string[curr] != string[n - curr - 1]:\n        return False\n\n    return check_palindrome_rec(string, curr + 1)\n\n\nif __name__ == \"__main__\":\n    string = input()\n    print(check_palindrome_rec(string, 0))\n</code></pre> <ul> <li>Print N fibonacci numbers:</li> </ul> <pre><code># Iterative method\ndef print_n_fibo(n):\n    a = 0\n    b = 1\n    for i in range(1, n + 1):\n        if i == 1:\n            print(0, end=\" \")\n        elif i == 2:\n            print(1, end=\" \")\n        else:\n            b = a + b\n            a = b - a\n            print(b, end=\" \")\n\n# Recursive method\ndef print_n_fibo_rec(n, a = 0, b = 1, curr = 1):\n    if curr &gt; n:\n        return\n    if curr == 1:\n        print(0, end=\" \")\n    elif curr == 2:\n        print(1, end=\" \")\n    else:\n        b = a + b\n        a = b - a\n        print(b, end=\" \")\n    print_n_fibo_rec(n, a, b, curr + 1)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    print_n_fibo_rec(n)\n    print(\"\\n\")\n    print_n_fibo(n)\n</code></pre>","tags":["ds-algo/basics/basic-recursion"]},{"location":"personal-notes/Notes/Problems_on_Basic_Recursion/#related-pages","title":"Related Pages","text":"<ul> <li>2024-07-28</li> </ul>","tags":["ds-algo/basics/basic-recursion"]},{"location":"personal-notes/Notes/Problems_on_Basic_Recursion/#references","title":"References","text":"","tags":["ds-algo/basics/basic-recursion"]},{"location":"personal-notes/Notes/Quick_Sort/","title":"Quick Sort","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#quick-sort-algorithm","title":"Quick Sort Algorithm","text":"<ul> <li> <p>Choose a pivot element has to from the array.</p> <ul> <li>The pivot element could be <ul> <li>the first element</li> <li>the last element</li> <li>any other element based on the implementation.</li> </ul> </li> </ul> </li> <li> <p>Place the pivot element in its correct position in a sorted array such that</p> <ul> <li>all elements smaller than the pivot are on the left side of the pivot</li> <li> <p>all elements greater than the pivot are on the right side of the pivot.</p> </li> <li> <p>Now the pivot element is in its correct position.</p> </li> </ul> </li> <li> <p>Recursively apply the above steps to the left and right sub-arrays.</p> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#notes-on-implementation","title":"Notes on Implementation","text":"<ul> <li> <p>The implementation of quick sort differs on how to place the pivot element     in its correct position. The following are the popular methods:</p> <ul> <li>Hoare's partition scheme - Uses two pointers</li> <li>Lomuto partition scheme - Uses one pointer</li> <li>Dutch National Flag algorithm - Uses three pointers</li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#notes-on-hoares-partition-scheme","title":"Notes on Hoare's partition scheme","text":"<ul> <li> <p>Consider the first element <code>arr[left]</code> as the pivot element.</p> </li> <li> <p>Start with 2 pointers one on the left + 1 (<code>l</code>) and another on the right (<code>r</code>).</p> </li> <li> <p>If <code>arr[l]</code> is less than the pivot, increment <code>l</code>. Continue this until <code>arr[l]</code> is      greater than the pivot. Stop.</p> </li> <li> <p>Now if <code>arr[r]</code> is greater than the pivot, decrement <code>r</code>. Continue this until <code>arr[r]</code> is     less than the pivot. Stop.</p> </li> <li> <p>At this situation <code>l</code> and <code>r</code> are pointing to elements that are on the wrong side      of the pivot. Swap <code>arr[l]</code> and <code>arr[r]</code>.</p> </li> <li> <p>Continue this process until <code>l</code> is greater than <code>r</code>.</p> </li> <li> <p>At the end <code>r</code> points to the correct position of the pivot element. Swap <code>arr[left]</code>      and <code>arr[r]</code>.</p> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#quick-sort-in-ascending-order","title":"Quick Sort in ascending order","text":"<ul> <li>Python Implementation (Hoaare's partition scheme)</li> </ul> <pre><code>def partition_hoare(arr, left, right):\n    pivot = arr[left]\n    l = left + 1\n    r = right\n    while l &lt;= r:\n        if arr[l] &lt;= pivot:\n            l += 1\n        elif arr[r] &gt;= pivot:\n            r -= 1\n        else:\n            arr[l], arr[r] = arr[r], arr[l]\n    arr[left], arr[r] = arr[r], arr[left]\n\n    return r\n\n\ndef quick_sort(arr, left, right):\n    if left &gt;= right:\n        return\n\n    partiton_index = partition_hoare(arr, left, right)\n    quick_sort(arr, left, partiton_index - 1)\n    quick_sort(arr, partiton_index + 1, right)\n\n\nif __name__ == \"__main__\":\n    input_arr = [int(ch.strip()) for ch in input().split(\",\")]\n    quick_sort(input_arr, 0, len(input_arr) - 1)\n    print(input_arr)\n</code></pre> <ul> <li>C++ Implementation (Hoare's partition scheme)</li> </ul> <pre><code>size_t partition_hoare(std::vector&lt;int&gt; &amp;arr, size_t left, size_t right) {\n    size_t l = left + 1, r = right;\n\n    int pivot = arr[left];\n\n    while (l &lt;= r) {\n        if (arr[l] &lt;= pivot) {\n            l++;\n        } else if (arr[r] &gt; pivot) {\n            r--;\n        } else {\n            std::swap(arr[l], arr[r]);\n        }\n    }\n\n    std::swap(arr[left], arr[r]);\n\n    return r;\n}\n\nvoid quick_sort(std::vector&lt;int&gt; &amp;arr, size_t left, size_t right) {\n    if (left &gt;= right) {\n        return;\n    }\n\n    size_t partition_index = partition_hoare(arr, left, right);\n    if (partition_index != 0) {                     // Prevents underflow\n        quick_sort(arr, left, partition_index - 1);\n    }\n    quick_sort(arr, partition_index + 1, right);\n}\n\nint main() {\n    IORedirector io_red(\"input.txt\", \"output.txt\");\n\n    std::string input;\n    std::getline(std::cin, input);\n    std::vector&lt;int&gt; input_arr = split&lt;int&gt;(input, ',');\n\n    quick_sort(input_arr, 0, input_arr.size() - 1);\n    print_vector(input_arr);\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#quick-sort-in-descending-order","title":"Quick Sort in descending order","text":"<ul> <li>Python Implementation (Hoare's partition scheme)</li> </ul> <pre><code>def partition_hoare_desc(arr, left, right):\n    pivot = arr[left]\n    l = left + 1\n    r = right\n    while l &lt;= r:\n        if arr[l] &gt;= pivot:\n            l += 1\n        elif arr[r] &lt;= pivot:\n            r -= 1\n        else:\n            arr[l], arr[r] = arr[r], arr[l]\n    arr[left], arr[r] = arr[r], arr[left]\n\n    return r\n\n\ndef quick_sort_desc(arr, left, right):\n    if left &gt;= right:\n        return\n\n    partiton_index = partition_hoare_desc(arr, left, right)\n    quick_sort_desc(arr, left, partiton_index - 1)\n    quick_sort_desc(arr, partiton_index + 1, right)\n\n\nif __name__ == \"__main__\":\n    input_arr = [int(ch.strip()) for ch in input().split(\",\")]\n    quick_sort_desc(input_arr, 0, len(input_arr) - 1)\n    print(input_arr)\n</code></pre> <ul> <li>C++ Implementation (Hoare's partition scheme)</li> </ul> <pre><code>size_t partition_hoare_desc(std::vector&lt;int&gt; &amp;arr, size_t left, size_t right) {\n    size_t l = left + 1, r = right;\n\n    int pivot = arr[left];\n\n    while (l &lt;= r) {\n        if (arr[l] &gt;= pivot) {\n            l++;\n        } else if (arr[r] &lt;= pivot) {\n            r--;\n        } else {\n            std::swap(arr[l], arr[r]);\n        }\n    }\n\n    std::swap(arr[left], arr[r]);\n\n    return r;\n}\n\nvoid quick_sort_desc(std::vector&lt;int&gt; &amp;arr, size_t left, size_t right) {\n    if (left &gt;= right) {\n        return;\n    }\n\n    size_t partition_index = partition_hoare_desc(arr, left, right);\n    if (partition_index != 0) {\n        quick_sort_desc(arr, left, partition_index - 1);\n    }\n    quick_sort_desc(arr, partition_index + 1, right);\n}\n\nint main() {\n    IORedirector io_red(\"input.txt\", \"output.txt\");\n\n    std::string input;\n    std::getline(std::cin, input);\n    std::vector&lt;int&gt; input_arr = split&lt;int&gt;(input, ',');\n\n    quick_sort_desc(input_arr, 0, input_arr.size() - 1);\n    print_vector(input_arr);\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#time-and-space-complexity","title":"Time and Space Complexity","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#time-complexity","title":"Time Complexity","text":"<ul> <li>Best Case - \\(O(nlog(n))\\)</li> <li>Average Case - \\(O(nlog(n))\\)</li> <li> <p>Worst Case - \\(O(n^2)\\)</p> </li> <li> <p>Reason: </p> <ul> <li>At each step, we divide the whole array, for that it takes \\(logN\\). </li> <li>\\(n\\) steps are taken for the part where find correct pivot index. </li> <li> <p>So time complexity will be \\(N \\times log(N)\\).</p> </li> <li> <p>There can be 2 cases:</p> <ul> <li> <p>Worst Case \u2013 This happens specifically when</p> <ul> <li>The array is in descending order and we want it to sort in ascending      order.</li> <li>While doing so we are choosing the first or last element as the pivot.     This results in one subarray with no elements and another with all      elements all the time.</li> </ul> </li> <li> <p>Best Case - This case occurs when the pivot is the middle element or      near to middle element of the array.</p> </li> </ul> </li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#space-complexity","title":"Space Complexity","text":"<ul> <li>\\(O(1) + O(N)\\) - We require \\(O(N)\\) for auxiliary stack space in the worst case.</li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#related-pages","title":"Related Pages","text":"<ul> <li>Merge_Sort</li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Quick_Sort/#references","title":"References","text":"<ol> <li>Cpp_helper_snippets</li> </ol>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Second_Largest_Element_in_Array/","title":"Find the second largest and second smallest element in an array","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/arrays/easy"]},{"location":"personal-notes/Notes/Second_Largest_Element_in_Array/#approach","title":"Approach","text":"<ul> <li> <p>We keep 2 flags for <code>largest</code> and <code>second_largest</code>. Initialized both to \\(MIN\\).</p> <ul> <li> <p>If an element is greater than <code>largest</code></p> <ul> <li> <p>Update the second_largest with largest</p> </li> <li> <p>Update the largest with current element</p> </li> </ul> </li> <li> <p>If the element is greater than <code>second_largest</code> only</p> <ul> <li>Update the second_largest with the current element.</li> </ul> </li> <li> <p>Repeat the above steps can for smallest also.</p> </li> </ul> </li> </ul>","tags":["ds-algo/arrays/easy"]},{"location":"personal-notes/Notes/Second_Largest_Element_in_Array/#code","title":"Code","text":"<ul> <li>C++ Implementation</li> </ul> <pre><code>std::pair&lt;int, int&gt; second_largest_element(const std::vector&lt;int&gt; &amp;arr) {\n    int largest = INT_MIN, second_largest = INT_MIN;\n    int smallest = INT_MAX, second_smallest = INT_MAX;\n    for (size_t i = 0; i &lt; arr.size(); ++i) {\n        if (arr[i] &gt; largest) {\n            second_largest = largest;\n            largest = arr[i];\n        } else if (arr[i] &gt; second_largest) {\n            second_largest = arr[i];\n        }\n\n        if (arr[i] &lt; smallest) {\n            second_smallest = smallest;\n            smallest = arr[i];\n        } else if (arr[i] &lt; second_smallest) {\n            second_smallest = arr[i];\n        }\n    }\n\n    return {second_largest, second_smallest};\n}\n\nint main() {\n    IORedirector io_red(\"input.txt\", \"output.txt\");\n\n    std::string input;\n    std::getline(std::cin, input);\n    std::vector&lt;int&gt; input_arr = split&lt;int&gt;(input, ',');\n\n    std::pair&lt;int, int&gt; elements = second_largest_element(test_arrs[i]);\n    std::cout &lt;&lt; elements.first &lt;&lt; \", \" &lt;&lt; elements.second;\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/arrays/easy"]},{"location":"personal-notes/Notes/Second_Largest_Element_in_Array/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Time complexity: \\(O(N)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>","tags":["ds-algo/arrays/easy"]},{"location":"personal-notes/Notes/Second_Largest_Element_in_Array/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/arrays/easy"]},{"location":"personal-notes/Notes/Second_Largest_Element_in_Array/#references","title":"References","text":"<ol> <li>Cpp_helper_snippets</li> </ol>","tags":["ds-algo/arrays/easy"]},{"location":"personal-notes/Notes/Selection_Sort/","title":"Selection Sort","text":"<p>000_Index_DS_Algo</p>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#selection-sort-algorithm","title":"Selection Sort algorithm","text":"<ul> <li> <p>First, we will select the range of the unsorted array using an outer loop (say <code>i</code>) that indicates the starting index of the range.</p> <ul> <li>Initially <code>i = 0</code> to <code>i = n-1</code> - we will have the entire array as our range.</li> </ul> </li> <li> <p>Now, in each iteration, we will select the minimum element from the range of the unsorted array using an inner loop.</p> </li> <li> <p>After that, we will swap the minimum element with the first element of the selected range(in step 1).</p> </li> <li> <p>Finally, after each iteration, we will find that the array is sorted up to the first index of the range.</p> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#notes-on-the-algorithm","title":"Notes on the algorithm","text":"<ul> <li> <p>Here, after each iteration, the array becomes sorted up to the first index of the range.</p> <ul> <li>That is why the starting index of the range increases by 1 after each iteration.</li> </ul> </li> <li> <p>This increment is achieved by the outer loop. The inner loop (i.e. j) helps to find the minimum element of the range <code>[i + 1 .. n - 1]</code>.</p> </li> <li> <p>The last index <code>i = N - 1</code> will be sorted automatically.</p> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#selection-sort-in-ascending-order","title":"Selection Sort in Ascending order","text":"<ul> <li>Python implementation</li> </ul> <pre><code># Bring the minimum number to the begining\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(0, n - 1):   # last number will be sorted\n        min_index = i\n        for j in range(i + 1, n):\n            if arr[j] &lt; arr[min_index]:\n                min_index = j\n        if min_index != i:\n            arr[i], arr[min_index] = arr[min_index], arr[i]\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    selection_sort(arr)\n    print(arr)\n</code></pre> <ul> <li>C++ implementation</li> </ul> <pre><code>// Bring minimum to the begining\nvoid selection_sort(std::vector&lt;int&gt; &amp;arr) {\n    size_t n = arr.size();\n    for (size_t i = 0; i &lt; n - 1; ++i) {   // last number will get sorted\n        size_t min_index = i;\n        for (int j = i; j &lt; n; ++j) {\n            if (arr[j] &lt; arr[min_index]) {\n                min_index = j;\n            }\n        }\n\n        if (i != min_index) {\n            swap(arr[i], arr[min_index]);\n        }\n    }\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    selection_sort(arr);\n\n    print_vector(arr);\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#selection-sort-in-descending-order","title":"Selection Sort in Descending order","text":"<ul> <li>Python implementation</li> </ul> <pre><code># Bring the maximum number to the begining\ndef selection_sort_desc(arr):\n    n = len(arr)\n    for i in range(0, n - 1):\n        max_index = i\n        for j in range(i + 1, n):\n            if arr[j] &gt; arr[max_index]:\n                max_index = j\n        if max_index != i:\n            arr[i], arr[max_index] = arr[max_index], arr[i]\n\n\nif __name__ == \"__main__\":\n    arr = [int(ch.strip()) for ch in input().split(\",\")]\n    selection_sort(arr)\n    print(arr)\n</code></pre> <ul> <li>C++ implementation</li> </ul> <pre><code>// Bring maximum to the begining\nvoid selection_sort_desc(std::vector&lt;int&gt; &amp;arr) {\n    size_t n = arr.size();\n    for (size_t i = 0; i &lt; n - 1; ++i) {\n        size_t max_index = i;\n        for (int j = i; j &lt; n; ++j) {\n            if (arr[j] &gt; arr[max_index]) {\n                max_index = j;\n            }\n        }\n\n        if (i != max_index) {\n            swap(arr[i], arr[max_index]);\n        }\n    }\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    std::string str;\n    std::getline(std::cin, str);\n\n    std::vector&lt;int&gt; arr = split&lt;int&gt;(str, ',');\n\n    selection_sort_desc(arr);\n\n    print_vector(arr);\n\n    return 0;\n}\n</code></pre>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#time-and-space-complexity","title":"Time and Space Complexity","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#time-complexity","title":"Time Complexity","text":"<ul> <li> <p>\\(O(n^2)\\) </p> <ul> <li>(where n = size of the array), for the best, worst, and average cases.</li> </ul> </li> <li> <p>Reason: </p> <ul> <li>The outer loop (say i) is running from 0 to n-2 i.e. n-1 times</li> <li> <p>for each i, the inner loop j runs from i to n-1. </p> <ul> <li>For, i = 0, the inner loop runs n-1 times, </li> <li>for i = 1, the inner loop runs n-2 times, and so on. </li> </ul> </li> <li> <p>So, the total steps will be approximately the following: </p> <ul> <li>\\((n-1) + (n-2) + (n-3) + \u2026\u2026..+ 3 + 2 + 1\\).</li> </ul> </li> <li>The is approximately the sum of the first n natural numbers \\((n*(n+1))/2\\).</li> <li>The precise time complexity will be \\(O(n^2/2 + n/2)\\).</li> <li>So Time Complexity is \\(O(n^2)\\). Here the value of n is N i.e. the size of the array.</li> </ul> </li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#space-complexity","title":"Space Complexity","text":"<ul> <li>\\(O(1)\\)</li> </ul>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Selection_Sort/#references","title":"References","text":"<ol> <li>Cpp_helper_snippets</li> </ol>","tags":["ds-algo/basics/sorting"]},{"location":"personal-notes/Notes/Sets_in_Python/","title":"Sets in Python","text":"<p>000_Index_DS_Algo Collections_in_Python</p> <ul> <li> <p>Collection of <code>objects</code> without duplicates - with no fixed ordering.</p> </li> <li> <p>Sets are mutable.</p> </li> <li> <p>Sets are defined as:</p> </li> </ul> <pre><code>s = {1, 2, 3}\ns = set()           # Empty Set\n\nprint(type(s))      # &lt;class 'set'&gt;\n\ns.add(3)\ns.add(2)\ns.add(2)            # Adding duplicate has no effect\n\nprint(s)            # {2, 3}\n</code></pre> <p>NOTE <code>s = {}</code> defines an empty <code>dictionary</code></p>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Sets_in_Python/#related-pages","title":"Related Pages","text":"<ul> <li>Dictionaries_in_Python</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Sets_in_Python/#references","title":"References","text":"<ol> <li>Sets-Python_Docs</li> </ol>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Strings_in_Python/","title":"Strings in Python","text":"<p>000_Index_DS_Algo Collections_in_Python</p> <ul> <li> <p>The name of class for strings is <code>str</code> . It's NOT string.</p> </li> <li> <p>To create new strings from other types use</p> </li> </ul> <pre><code>newStr = str(x)\n</code></pre> <ul> <li> <p>strings are immutable.</p> </li> <li> <p>concatenate two strings with <code>+</code> to create a new string.</p> </li> <li> <p>Individual characters can be accessed using <code>[]</code> and zero based index.</p> </li> <li> <p>Negative index starts counting from end.</p> </li> </ul> <pre><code>n = str(9876)\nprint(n[-1])    # 6\n</code></pre>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Strings_in_Python/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Strings_in_Python/#references","title":"References","text":"<ol> <li>Text - Python Docs</li> </ol>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Tuples_in_Python/","title":"Tuples in Python","text":"<p>000_Index_DS_Algo Collections_in_Python</p> <ul> <li> <p>Ordered sequence of objects like lists but they are immutable.</p> </li> <li> <p>We can access individual elements with bracket syntax but can't modify   them.</p> </li> </ul> <pre><code>t = ()          # Empty Tuple\nt = (1, 2, \"skip a few\", 99, 100)\nprint(type(t))  # &lt;class 'tuple'&gt;\nprint(t[4])     # 100\n</code></pre> <ul> <li>For <code>list</code> and <code>tuple</code> Ordered means that the items have a defined   order (defined when created), and that order will not change.</li> </ul>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Tuples_in_Python/#related-pages","title":"Related Pages","text":"","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/Tuples_in_Python/#references","title":"References","text":"<ol> <li>Tuples-Python Docs</li> </ol>","tags":["ds-algo/lang-basic/py"]},{"location":"personal-notes/Notes/qpdf_commands/","title":"<code>qpdf</code> Commands","text":"<p>To create a new PDF by selecting pages </p> <ol> <li>Keeping the TOC intact - </li> </ol> <pre><code>qpdf Data\\ Structures\\ and\\ Algorithms\\ in\\ Python.pdf --pages . 78-108 -- OOPsWithPython.pdf\n</code></pre> <ol> <li>Deleting the TOC entirely</li> </ol> <pre><code>qpdf --empty --pages Data\\ Structures\\ and\\ Algorithms\\ in\\ Python.pdf 78-108 -- OOPsWithPython.pdf\n</code></pre> <ol> <li>Decrypting a password protected pdf</li> </ol> <pre><code>qpdf --password=&lt;password&gt; --decrypt &lt;Encrypted.pdf&gt; output.pdf\n</code></pre>","tags":["system"]},{"location":"personal-notes/Notes/qpdf_commands/#related-pages","title":"Related Pages","text":"","tags":["system"]},{"location":"personal-notes/Notes/qpdf_commands/#references","title":"References","text":"","tags":["system"]},{"location":"personal-notes/Notes/ds_algo_notes/cpp_basic_notes/","title":"CPP Notes for DSA","text":"","tags":[]},{"location":"personal-notes/Notes/ds_algo_notes/cpp_basic_notes/#input-and-output","title":"Input and Output","text":"<ul> <li>Create two files <code>input.txt</code> and <code>output.txt</code>, for input and output.</li> <li>Within <code>main</code> use the following:</li> </ul> <pre><code>int main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n\n    // ... Other code here\n}\n</code></pre>","tags":[]},{"location":"personal-notes/Notes/ds_algo_notes/cpp_basic_notes/#data-types","title":"Data Types","text":"","tags":[]},{"location":"personal-notes/Notes/ds_algo_notes/cpp_basic_notes/#strings-and-getline","title":"Strings and <code>getline</code>","text":"<ul> <li>To use strings use <code>#include&lt;string&gt;</code>.</li> <li>To read a single line from input at a time use</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main() {\n    string str;\n    getline(cin, str);\n\n    // .. Other code here\n}\n</code></pre>","tags":[]},{"location":"personal-notes/Notes/ds_algo_notes/cpp_basic_notes/#arrays","title":"Arrays","text":"<ul> <li>To define a 2D array use <code>int arr[3][5]</code>.</li> <li>3 - No of rows. 5 - no of columns.</li> <li>It's stored linearly.<ul> <li>First entire column of row 1 is stored.</li> <li>Next entire column of row 2 is stored and so on.</li> </ul> </li> </ul>","tags":[]},{"location":"personal-notes/Notes/ds_algo_notes/cpp_basic_notes/#related-pages","title":"Related Pages","text":"<p>-</p>","tags":[]},{"location":"personal-notes/Notes/ds_algo_notes/cpp_basic_notes/#references","title":"References","text":"<p>1.</p>","tags":[]},{"location":"personal-notes/Templates/Basic%20Template/","title":"{{title}}","text":""},{"location":"personal-notes/Templates/Basic%20Template/#related-pages","title":"Related Pages","text":""},{"location":"personal-notes/Templates/Basic%20Template/#references","title":"References","text":""}]}